package ru.cryhards.brootkiddie.items

import com.badlogic.gdx.Gdx
import com.badlogic.gdx.graphics.Color
import com.badlogic.gdx.scenes.scene2d.Actor
import com.badlogic.gdx.scenes.scene2d.InputEvent
import com.badlogic.gdx.scenes.scene2d.utils.ClickListener
import ru.cryhards.brootkiddie.Core
import ru.cryhards.brootkiddie.Environment
import ru.cryhards.brootkiddie.ui.UI

/**
 * Represents a malware used for attacks
 */
class Malware(title: String, info: String, iconTexturePath: String) : Item(title, info, iconTexturePath, Item.Type.MALWARE), Combinable {
    /**
     * Pieces of code that is is combined of
     */
    var scripts = ArrayList<Script>()


    init {
        val setGlobalMapMalware = UI.GlitchTextButtonCompact(
                if (Environment.activeMalware == this)
                    "DEACTIVATE"
                else
                    "ACTIVATE")

        setGlobalMapMalware.addListener(object : ClickListener() {
            override fun clicked(event: InputEvent?, x: Float, y: Float) {
                if (Environment.activeMalware == this@Malware) {
                    Gdx.app.log("activeMalware", "deactivated")
                    Environment.UI.console?.log("$title deactivated")
                    Environment.activeMalware = null
                    setGlobalMapMalware.setText("ACTIVATE")
                } else {
                    Gdx.app.log("activeMalware", "activated")
                    Environment.activeMalware = this@Malware
                    Environment.UI.console?.log("$title activated")
                    setGlobalMapMalware.setText("DEACTIVATE")
                }
            }
        })

        val inspectMalware = UI.GlitchTextButtonCompact("INSPECT")
        inspectMalware.addListener(object : ClickListener() {
            override fun clicked(event: InputEvent?, x: Float, y: Float) {
                Core.instance.toBench(this@Malware)
            }
        })

        actions.add(setGlobalMapMalware)
        actions.add(inspectMalware)
    }


    constructor(title: String, info: String, iconTexturePath: String, vararg scripts: Script) : this(title, info, iconTexturePath) {
        for (s in scripts)
            this.scripts.add(s)
        update()
    }


    /**
     * Represents malware parameters
     */
    val stats = Stats()

    /**
     * Represents malware parameters
     */
    class Stats {
        var suspiciousness = 0f
        var spreadingSpeed = 0f
        var infectiousness = 0f
        var miningSpeed = 0f

        /**
         * Adds extra value to the stats
         */
        fun modulateBy(stats: Stats) {
            suspiciousness += stats.suspiciousness
            spreadingSpeed += stats.spreadingSpeed
            infectiousness += stats.infectiousness
            miningSpeed += stats.miningSpeed
        }
    }


    /**
     * Adds new effect to this and returns this
     */
    fun combine(effect: Effect): Malware {
        title += effect.title.subSequence(0, 3)
        info += " and " + effect.title
        effects.add(effect)
        update()
        return this
    }

    operator fun plus(effect: Effect) = combine(effect)


    /**
     * Adds new script to this and returns this
     */
    fun combine(script: Script): Malware {
        title += script.title.subSequence(0, 3)
        info += " and " + script.title
        scripts.add(script)
        update()
        return this
    }

    operator fun plus(script: Script) = combine(script)


    /**
     * Adds new malware scripts to this and returns this
     */
    fun combine(malware: Malware): Malware {
        title += malware.title
        info += " and " + malware.title
        malware.scripts.forEach { scripts.add(it) }
        malware.effects.forEach { effects.add(it) }
        update()
        return this
    }

    operator fun plus(malware: Malware) = combine(malware)


    /**
     * Combines the given item with itself
     */
    override fun combine(item: Item): Malware {
        if (item is Script)
            return combine(item)
        if (item is Malware)
            return combine(item)
        return this
    }

    operator fun plus(item: Item) = combine(item)


    /**
     * Recalculates malware stats
     */
    fun update() {
        stats.suspiciousness = 0f
        stats.spreadingSpeed = 0f
        stats.infectiousness = 0f
        stats.miningSpeed = 0f

        scripts.forEach { stats.modulateBy(it.affection()) }
        effects.forEach { it.affect(this.stats) }
        Gdx.app.log("Malware", "Updated")
    }


    /**
     * Used to lay out custom stuff in explorer
     */
    override fun represent(): Array<Actor> {
        val out = ArrayList<Actor>()

        val scr = UI.StaticLabel("Scrits:")
        scr.setWrap(true)
        scr.style.background = null
        scr.color = Color.BROWN
        if (scripts.size != 0)
            scripts.forEach { scr.setText(scr.text.toString() + "\n * ${it.title}\n ${it.info}") }
        else
            scr.setText(scr.text.toString() + "\n ** NONE **")
        out += scr

        val st = UI.StaticLabel("Stats:\n")
        st.setWrap(true)
        st.style.background = null
        st.color = Color.GREEN
        st.setText(st.text.toString() +
                "Infectiousness: ${stats.infectiousness}\n" +
                "Spreading Speed: ${stats.spreadingSpeed}\n" +
                "Suspiciousness: ${stats.suspiciousness}\n" +
                "Mining Speed: ${stats.miningSpeed}")
        out += st

        val eff = UI.StaticLabel("Effects:")
        eff.setWrap(true)
        eff.style.background = null
        eff.color = Color.CORAL
        if (effects.size != 0) {
            effects.forEach { eff.setText(eff.text.toString() + "\n * ${it.title}\n ${it.info}") }
            out += eff
        }

        actions.forEach { out += it }
        return out.toTypedArray()
    }


    override fun toString(): String {
        return "Infectiousness: ${stats.infectiousness}\n" +
                "Spreading Speed: ${stats.spreadingSpeed}\n" +
                "Suspiciousness: ${stats.suspiciousness}\n" +
                "Mining Speed: ${stats.miningSpeed}"
    }

    override fun clone(): Any {
        return super<Combinable>.clone()
    }
}